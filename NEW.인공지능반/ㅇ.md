1. 순차 탐색 (Sequentital ...
..
데이터까지 차례로 데이터를 비교하는 알고리즘이다.
리스트의 시작부터 마지막까지 N개의 데티어들을 평균적으로 비교해야 하므로 실행 시간은 평균적으로 0(N)이다.

```
# 일치하는 데이터의 인덱스 값을 반환한다.
# 찾지 못하는 경우 None을 반환한다.
def sequentital_search(dataList, targetdat
...

```

2. 이진 탐색 (Binary search)
분할-정복(Divide and Conquer)방식을 적용한 탐색 알고리즘이다. 알고리즘의 특성상 N개의 데이터 리스트에서 데이터를 비교하는 횟수는 logN + 1회 이상을 넘지 않는다.

대신, 리스트....

이미지들

....

3. middle 에 있는 값이 target이 아닌 경우
a. Array[middle] < targer 인 경우 찾는 값은 오른쪽에 있으므로 left = middle + 1
b. Array[middle] ]

또 이미지들 

4. 반복중 left > right인 경우 탐색 범위가 역전되었으므로 반복을 멈추고 값을 찾지 못하였음을 알린다. ...

```
def binary_search(dataList, targetData):
	# Left와 right 초기값 지정
	left =0
	right = len(dataList) - 1

	# 값을 찾거나 left < right 인 경우 멈춤
	while left <= right:
		# middle의 값이 targetData이면 middle 반환
		middle = (left + right) // 2

		if dataList[middle] == targetData:
			# middle 의 값이 targerData이면 middle 반환
			return middle

		elif dataList[middle] < targetData:
			# middle 값이 targetData보다 작으면 middle 오른쪽에서 찾음
			left = middle + 1
		else:
			# middle의 값이 target보다 크면 middle 왼쪽에서 찾음
			right = middle - 1

	return None # 찾지 못함

array = [1, 3, 4, 6, 7, 10, 13, 14, 18, 19, 21, 24, 37, 40, 45, 71]
print(binary_search(array, 7)) # 출력 : 4
```
