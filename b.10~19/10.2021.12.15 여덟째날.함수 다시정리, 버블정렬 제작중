똑같은 코드를 반복해야 할때.
코드의 간소화. 여러 코드를 효율적으로 처리하기 위해 묶어서 처리하는 함수.
funtion /하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 프로그램 코드의 집합.
def 함수이름(): /함수 선언
def test():
    print("HI")

선언한 함수를 사용자 함수라 한다.

실행할 경우
def test():
    print("HI")
test() /함수 호출

실행할 경우 /HI

len같은 함수는 괄호안에 값을 요구한다.
사용자 함수 또한 값을 요구하게 할수 있다.

def test(a): /괄호안에 요구하는 값을 넣는다. 여러개를 넣을수 있다.

값을 않넣었을 경우

def test(a):
    print("HI")

test()

Traceback (most recent call last):
  File "C:/Users/scratch4/PycharmProjects/pythonProject1/d.py", line 4, in <module>
    test()
TypeError: test() missing 1 required positional argument: 'a'

값을 넣었을 경우

def test(a):
    print("HI")

test(이곳에 넣은 것이 잠시 변수 a로 변한다.)

def test(a):
    print("a")

예)
test(4)

def test(a):
    print(a)

test(4)

실행 결과
4

여기서 잠깐
C언어 에서는 변수를 선언할때
int a = 1;
어떤 형식의 변수인지를 말해줘야 한다.
미리 형식을 정해놓고 값을 넣어야 하지만

파이썬에서는 값을 넣으면 값에 맞춰 변수 상태가 정해진다.

그렇기 때문에
def test(a):
    print(a)

test("이곳에 문자를 넣는다면")

실행할 경우
이곳에 문자를 넣는다면

변수 상태가 없는것 빼고 전부 넣을수 있다.

이것을 활용하여 
def math(a,b):
    print(a+b)
math(int(input()),int(input()))

두 수를 받아서 더한뒤 출력하는 함수를 만들수 있다.

함수를 선언할때 이미 파이썬에 있는 함수와 이름을 같게 할 경우 코드가 꼬일 확률이 높다.
그래서 거의 쓰지 않는다.
그래서 사용할경우 뒤에 언더바[ _ ]를 붙인다.

함수는 값을 받으면 실행한 값을 가지고 있을수 있다.
예를 들어 input()으로 받은 값은 inout이 가지고 있지만 저장된것은 아니니
a=input()을 통해 a에 저장을 할수 있다.
사용자 함수 또한 가능하다.
사용자 함수에서 사용 가능한 함수로 return이라는 함수가 있다.
이 함수는 사용자 함수에서 실행한 값을 사용자 함수가 가지고 있도록 돌려주는 함수이다.

def test(a,b):
    return a+b

c=test(5,7)

print(c)

맨 처음 사용자 함수 test는 a와 b의 값을 요구했고
test(5,7)을 통하여 값을 주었다.

두번째 줄에서 a+b 한 값을 return을 통하여 돌려주어
test함수가 a+b를 계산한 값을 가지게 되었고
세번째 줄에서 test함수가 가지고 있는, a+b의 값을 c에 저장한 것 이다.

return은 사용자 함수에서 값을 돌려주는 함수이다.

return을 사용하는 이유는 사용자 함수 내부와 외부공간이 서로 상호작용이 불가능 하기 때문.

간단정리:함수란? 함수에 X를 집어 넣으면 함수가 계산하여 Y라는 값으로 돌려주는 것.

버블정렬이란? 7,5,9,4,1 이라는 수가 있을경우 첫번째 자리수와 두번째 자리수를 비교, 큰 수를 
오른쪽으로 옮기고, 옮겨진 두번째와 세번째 자리수 숫자를 비교, 큰 수를 오른쪽으로 옮기는 것을
모든 수가 끝날때까지 반복하고 또 한번 반복하여 작은수 부터 큰수 까지 정렬하는 방법이다.

버블정렬 제작중

import random
o=0
p=1
j=0
q=()
w=()
a=[]
for i in range(5):
    a.append(random.randrange(1,101))
print(a)
#while j==0:
while p < 5:
    if a[o] < a[p]:
        o=o+1
        p=p+1
        continue
    elif a[o] > a[p]:
        q = a[o]
        w = a[p]
        a[p] = q
        a[o] = w
        o=o+1
        p=p+1
print(a)
