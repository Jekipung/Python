#a = "Hello world"

# 인덱싱
#print(a[0])     # 인덱스 번호는 0부터 시작한다.
#print(a[-1])    # 인덱스 번호에 마이너스(-)를 붙이면 뒤에서부터 센다.

# 슬라이싱   [시작인덱스:끝인덱스(+1):step]
#print(a[0:5])   # 인덱스 번호 0부터 4까지 문자열을 읽겠다.
#print(a[::-2])  # 처음부터 끝까지 뒤에서 인덱스 번호를 -2 씩 읽겠다.

# 사용 가능한 자료형은 리스트, 튜플, 문자열이 있다.

# 문자열 연산 (문자열 + 문자열,문자열 * 정수)
#a = "Hello"
#b = "World"

#print(a+b)
#print(a*3)

# a 와 b를 이용해서 Hello world!
#print(a+" "+b+"!")

# is붙은 멤버 메소드들은 True 또는 False를 리턴한다.
#print(a.isdigit())

#immutable 변하지 않음

#print(a.replace("H","D"))
#          "old str", "new str"

# 리스트 muttable
#a = [1,2,'A','B'[1,2]]

#a = [1,2,3,[4,5,[6,7],8],9]

# a에서 값 7 뽑아내기(인덱싱)
#print(a[3])
#print(a[3][2])
#print(a[3][2][1])

# 리스트 연산(리스트 + 리스트 , 리스트 * 정수)
#a = [4,1,3,2]
# b = [5,8,7]
# print(a+b)
# print(a*3)

# 리스트의 원소 수정 3 -> 6
#a = [4,1,3,2]
#a[2] = 6

#리스트의 원소 삭제 [4,1,6,2] -> [4,1,2]
#del a[2]
#print(a)

#a = ['a','b','c','d']
# del a[2]
# print(a)
#or
#a.remove('c')
#print(a)

# 튜플(Tuple) immutable (튜플 + 튜플, 튜플 * 정수)
# t = (1, 2, 3)
# print(type(t))

# print(t[0])

# dictionary -hash 순차적으로 원소값을 구하지 않는다. =인덱스를 사용하지 않는다.
# d = {"key":"value"}
# print(d["key"])

# d = {'apple':'사과'}
# print(d)
# 딕셔너리에 value 수정
# d['apple'] = '파인애플'
# print(d)
# 딕셔너리에 key - value 추가
# d['banana'] = '바나나'
# print(d)
# 딕셔너리에 삭제
# del d['apple']
# print(d)

#key는 imuutable한 원소만 쓸수 있다.
# d2 = {('a','b'):'value'}
# print(d2['a','b'])

d = {'a':1, "b":2,"c":3}

# 딕셔너리 멤버 메소드
# print(d.keys())
# print(d.values())
# print(d.items())

# key 또는 value값을 확인
# print('a' in d.keys())
# print('a' in d)
# print(1 in d.values())

# for문에서 딕셔너리 활용
# for i in d():
#     print(i)

# for i in d():
#     print(d[i])

# for i in d.values():
#     print(i)

# 중복된 key값 사용시 문제
# d = {"A":"에이", "A":"비", "A":"씨"}
# print(d["A"])
# d["A"] = '디'
# print(d)

# 집합
s = set()
#or
# s = {1,2,3}

# print(type(s))

# 중복된 값을 제거해준다.
# l = [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]
# s1 = set(l)
# print(s1)

# 순서가 없다.
# ss = "Hello"
# s2 = set(ss)
# print(s2)
