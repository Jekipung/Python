밸만 포드 알고리즘

```
# 밸먼-포드 알고리즘 함수
# matrix: 가중치 인접 행렬
# start 시작  노드
def bellman_ford(matrix,start):
    # 노드의 개수
    v = len(matrix)

    # 1. 최단 거리 테이블 초기화

    distance = [float('inf')] * v

    # 2. 출발 노드 설정
    distance[start] = 0

    # 3. 모든 노드에 대하여 최소 비용 계산
    # (v 번, 마지막 음의 사이클 검사까지 포함함)
    for n in range(v):
        for x in range(v):
            for y in range(v):
                cost = matrix[x][y]

                # 최소 비용 갱신
                # 원래라면 distance[x] != float('inf')를 검사해야한다.
                # 여기서 검사하지 않은 이유는 어짜피 int + x == inf 이기 때문
                if distance[y] > distance[x] + cost:
                    distance[y] = distance[x] +cost

                    # 4. v번째에 갱신이 발생했다면 최단 거리를 구할 수 없음
                    if n == v - 1:
                        return False, distance

    return True, distance

inf = float('inf')
amatrix = [
    [0,     7,   5,   3, inf],
    [inf,   0, inf, inf, inf],
    [inf, inf,   0,   3,   3],
    [inf,   3, inf,   0,  -6],
    [inf, inf,   2, inf,   0]
]

success, distance = bellman_ford(amatrix, 0)
print('최단 경로의 존재:', success) # False
print('마지막 계산된 최단 경로', distance) # [0, 3, -4, -1, -6]

amatrix2 = [
    [0,     3,   5,   1, inf],
    [inf,   0,   6, inf,   4],
    [inf, inf,   0,  -3,  -3],
    [inf,  -2, inf,   0,  -1],
    [inf, inf, inf, inf,   0]
]

success, distance = bellman_ford(amatrix2, 0)
print('최단 경로의 존재:', success) # True
print('마지막 계산된 최단 경로:', distance) # [0, -1, 5, 1, 0]
```

[백준 타임머신 문제](https://www.acmicpc.net/problem/11657)

```
# 도시의 개수 N, 버스 노선의 개수 M
N, M = map(int, input().split())

# 인접 리스트
alist = [[] for _ in range(N +1 )]

# 버스 노선의 정보 A, B, C -> (시작, 도착, 시간)
for _ in range(M):
    A, B, C = map(int, input().split())
    # A -> B에 대한 인접 리스트 생성
    alist[A].append([B,C])

# 최단 거리 테이블 초기화
distance = [float('inf')] * (N + 1)

# 시작 노드 설정
distance[1] = 0

# 모든 정점에 대하여 N번 순회
for n in range(N):
    for a in range(1, N + 1):
        for b, c in alist[a]:
            if distance[b] > distance[a] + c:
                distance[b] = distance[a] + c

                if n == N - 1:
                    print(-1)
                    exit(0)

# 시간을 한줄 씩 출력
for answer in distance[2:]:
    print(answer if float('inf') > answer else -1)
```
